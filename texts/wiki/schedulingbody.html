Here I discuss theree different scheduling mechanisms: The one of &nbsp;event-driven user interfaces such is the Window managers in Windows and Linux. In the other side, the MVC REST scheduling of MVC-AJAX-REST applications. Finally how MFlow handles requests.<br><br>While the first has no navigation, there is a single page, the second incorporates navigation, but with a routing configuration, normally expressed as program data or as a static configuration in a different declarative language. While a desktop window application route window events to event handlers in the program, the MVC applications can handle page request, that are routed to request handlers that return entire pages or to AJAX handlers that return data that is used by client javascript programs to update the current page.<br><br>In MFlow the routing, the page handlers and the AJAX handlers are implicit in a single piece of Haskell code. Because is code, not configuration neither data, the navigation is assured by the same type safety guaranteed by Haskell. There is no route without request handler, since that would produce a undefined function at compilation time. In the other side, the navigation may be as flexible as required. For example, a URL can point to a page that need validation, in wich case the login page will appear if the user has no access rights. This is not something that need special coding or configuration. there are no special machinery for that. It is a consequence of how the navigation monad consumes the path of the URL of the request.&nbsp;<br><br>Within the page &nbsp;<br>